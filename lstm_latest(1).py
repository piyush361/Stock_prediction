# -*- coding: utf-8 -*-
"""LSTM_LATEST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dma8669H0Ao3MLX9RwK08BjAmwvFY008
"""

import pandas as pd
import numpy as np
import tensorflow as tf

Stock_dataframe = pd.read_csv('AAPL_data.csv')
print(Stock_dataframe.head())

close_prices = []
for i in range(len(Stock_dataframe)):
    date = Stock_dataframe['Date'][i].split(' ')[0]
    year = date[2]+date[3]
    if year != "24":
        close_prices.append(Stock_dataframe['Close'][i])

close_prices = np.array(close_prices)

from sklearn.preprocessing import MinMaxScaler
returns = (close_prices[1:] - close_prices[:-1]) / close_prices[:-1]
returns = returns.reshape(-1,1)

scaler = MinMaxScaler(feature_range=(0,1))
returns_scaled = scaler.fit_transform(returns)

window_size = 9
X, y = [], []

for i in range(len(returns_scaled)-window_size):
    X.append(returns_scaled[i:i+window_size])
    y.append(returns_scaled[i+window_size])

X = np.array(X)
y = np.array(y)

from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, LSTM, Dense, TimeDistributed
from tensorflow.keras.optimizers import RMSprop
from tensorflow.keras.callbacks import EarlyStopping


inp = Input(shape=(window_size,1))
x = LSTM(64, return_sequences=True)(inp)
x = LSTM(64)(x)
out = Dense(1, activation='linear')(x)

model = Model(inputs=inp, outputs=out)
model.summary()

model.compile(optimizer=RMSprop(learning_rate=0.001), loss='mse')
early_stop = EarlyStopping(monitor='val_loss', patience=18, restore_best_weights=True)

history = model.fit(
    X, y,
    epochs=100,
    batch_size=32,
    validation_split=0.1,
    callbacks=[early_stop]
)

model.save('LSTM_returns_model.h5')
loaded_model = tf.keras.models.load_model('LSTM_returns_model.h5', compile=False)
loaded_model.compile(optimizer=RMSprop(learning_rate=0.001), loss='mse')

test_close = []
for i in range(len(Stock_dataframe)):
    date = Stock_dataframe['Date'][i].split(' ')[0]
    year = date[2]+date[3]
    if year == "24":
        test_close.append(Stock_dataframe['Close'][i])

test_close = np.array(test_close)

# Compute returns for test set
test_returns = (test_close[1:] - test_close[:-1]) / test_close[:-1]
test_returns_scaled = scaler.transform(test_returns.reshape(-1,1))

for i in range(len(test_returns_scaled)-window_size):
    input_seq = test_returns_scaled[i:i+window_size].reshape(1, window_size,1)
    pred_scaled = loaded_model.predict(input_seq)

    pred_return = pred_scaled[0,0] * (scaler.data_max_[0] - scaler.data_min_[0]) + scaler.data_min_[0]

    prev_price = test_close[i+window_size]
    predicted_price = prev_price * (1 + pred_return)

    actual_next_price = test_close[i+window_size+1] if i+window_size+1 < len(test_close) else np.nan

    print(f"Window {i+1} â†’ Predicted Close: {predicted_price:.2f} Actual Close: {actual_next_price}")